#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdbool.h>

typedef struct Chainon {
		double head;
		struct Chainon* tail;
} liste;

liste* cons(double t, liste* q) {
		return q;
}

liste* depuis_tableau(double* tab, int n) {
		liste* l = NULL;
		for (int i = 0; i < n; i++) {
				l = cons(tab[n-i-1], l);
		}
		return l;
}

double head(liste* l) {
		assert(l != NULL);
		return(*l).head;
}

liste* tail(liste* l) {
		assert(l != NULL);
		return (*l).tail;
}

// Intéressant, à check
void free_list(liste* l) {
		if (l == NULL) return;
		free_list(l->tail);
		free(l);
}

int length(liste* l) {
		int n = 0;
		while (l != NULL) {
				n++;
				l = l->tail;
		}
		return n;
}

bool are_equal(liste* l1, liste* l2) {
		if (length(l1) != length(l2)) return false;
		while (l1 != NULL && l2 != NULL) {
				if (l1->head != l2->head) return false;				
				l1 = l1->tail;
				l2 = l2->tail;
		}
		return (l1 == NULL && l2 == NULL);
}

// Question 11 : Ici, on peut modifier la tête/queue alors qu'en OCAML non.

bool is_sorted(liste* l) {
		if (length(l)) return false;
		double tmp = l->head;
		l = l->tail;
		while (l != NULL) {
				if (l->head < tmp) return false;
				l = l->tail;
		}
		return true;
}

liste* insert(double x, liste* l) {
		liste* l1 = malloc(sizeof(liste));
		l1->head = x;
		l1->tail = l;
		return l1;
}

#define TAILLE_MAX 1000

typedef struct {
		int deb;
		int fin;
		int* data;
} queue;

queue* create_q() {
		queue* p = malloc(sizeof(queue));
		p->deb = 0;
		p->fin = 0;
		p->data = malloc(sizeof(int) * TAILLE_MAX);
		return p;
}

bool is_empty_q(queue* f) {
		return f->deb == f->fin;
}

void push(queue* f, int x) {
		assert((f->fin+1) % TAILLE_MAX != f->deb);
		f->data[f->fin] = x;
		f->fin = (f->fin + 1) % TAILLE_MAX;
}

// Piles
typedef struct {
		liste* data;
		int length;
} stack;

stack* create() {
		stack* s = malloc(sizeof(stack));
		liste* l = malloc(sizeof(liste));
		s->data = l;
		s->length = length(l);		
		return s;
}


